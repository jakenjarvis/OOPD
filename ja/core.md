## オブジェクト指向型汎用プロンプト用語定義 (Object-Oriented Terminology for Prompt Design)

この章は、AIがオブジェクト指向プログラミング (OOP) の概念を **プロンプトの構造化と解釈** に利用するための **Object-Oriented Prompt Design (OOPD)** についての **最重要** 用語定義です。以下の定義は、 **プロンプトの記述とAIの応答生成における思考フレームワーク** として使用されます。プロンプトを解釈し、必要に応じてOOPの原則を適用して、より構造的で一貫性のある応答を生成するために利用してください。

**本ドキュメントにおける用語の分類:**

- **基本用語 (Basic Terms):** この章で定義されるコア概念（クラス、オブジェクト等）。これらは **構造化されたプロンプト記述** における構造を定義する **固定キーワード** として扱います。AIはこれらの用語を、後述の「基本用語 表記」で定義された各言語の固定表記に基づいて認識し、指定された言語の固定表記で応答に使用します（翻訳処理は行いません）。
- **翻訳用語 (User-Defined Identifiers):** ユーザーが **プロンプト内で構造的に定義** する具体的なクラス名、メソッド名、プロパティ名などに含まれる単語。これらは、ユーザーが記述した言語から **ハブ言語（英語）** へ、AIが **英語命名規則** と **翻訳ルール（命名パターン、コア対訳リスト）** に基づいて推論・変換する対象です。AIは初回推論結果を記憶し、セッション内での一貫性を保ちます。

### クラス (Class)

- 定義: オブジェクトの設計図。
- 重要ポイント:
  - オブジェクトの種類を定義。
  - 複数のオブジェクトを作成可能。
- 例: `犬 (Dog)` クラス。動物の種類を定義する。この設計図から、様々な名前や特徴を持つ犬のオブジェクト（インスタンス）を生成できる。

**基本用語 表記 (Basic Term Notations):**

```json
{
  "en": "Class", "ja": "クラス", "zh-CN": "类", "zh-TW": "類別", "es": "Clase", "fr": "Classe", "de": "Klasse", "ko": "클래스", "pt": "Classe", "ru": "Класс", "ar": "فئة", "hi": "क्लास"
}
```

### オブジェクト (Object)

- 定義: クラスから生成された実体。
- 重要ポイント:
  - クラスを基に生成。
  - 状態と振る舞いを持つ。
  - 「犬」という種類の概念を指す。
- 例: `ポチ (Pochi)` は `犬 (Dog)` クラスのオブジェクト。名前、年齢、毛色などの情報を持つ。

**基本用語 表記 (Basic Term Notations):**

```json
{
  "en": "Object", "ja": "オブジェクト", "zh-CN": "对象", "zh-TW": "物件", "es": "Objeto", "fr": "Objet", "de": "Objekt", "ko": "객체", "pt": "Objeto", "ru": "Объект", "ar": "كائن", "hi": "ऑब्जेक्ट"
}
```

### インスタンス (Instance)

- 定義: クラスという設計図を基に、実際に作られた個別の実体。(オブジェクトとほぼ同義)
- 重要ポイント:
  - クラスを基に生成。
  - 状態と振る舞いを持つ。
  - 「ポチ」という具体的な犬を指す。
- 例: `ポチ (Pochi)` は `犬 (Dog)` クラスのインスタンス。具体的に「ポチ」という名前の犬を指し、それぞれ異なる状態を持つことができる。

**基本用語 表記 (Basic Term Notations):**

```json
{
  "en": "Instance", "ja": "インスタンス", "zh-CN": "实例", "zh-TW": "實體", "es": "Instancia", "fr": "Instance", "de": "Instanz", "ko": "인스턴스", "pt": "Instância", "ru": "Экземпляр", "ar": "مثيل", "hi": "इंस्टेंस"
}
```

### プロパティ (Property)

- 定義: オブジェクトが持つ属性。
- 重要ポイント:
  - オブジェクトの状態を表す。
- 例: `犬 (Dog)` クラスの `名前 (Name)` プロパティ。犬の名前を格納する。

**基本用語 表記 (Basic Term Notations):**

```json
{
  "en": "Property", "ja": "プロパティ", "zh-CN": "属性", "zh-TW": "屬性", "es": "Propiedad", "fr": "Propriété", "de": "Eigenschaft", "ko": "속성", "pt": "Propriedade", "ru": "Свойство", "ar": "خاصية", "hi": "प्रॉपर्टी"
}
```

### メソッド (Method)

- 定義: オブジェクトが行う動作。
- 重要ポイント:
  - オブジェクトの振る舞いを定義。
- 例: `犬 (Dog)` クラスの `吠える (Bark)` メソッド。犬が吠える動作を定義する。

**基本用語 表記 (Basic Term Notations):**

```json
{
  "en": "Method", "ja": "メソッド", "zh-CN": "方法", "zh-TW": "方法", "es": "Método", "fr": "Méthode", "de": "Methode", "ko": "메소드", "pt": "Método", "ru": "Метод", "ar": "طريقة", "hi": "मेथड"
}
```

### 型 (Type)

- 定義: データの種類。
- 重要ポイント:
  - プロパティや引数の種類を指定。
  - 整合性を高める。
- 例:
  - `アイテムID (整数型)`: アイテムIDは整数型である。数値のみを格納できる。
  - `アイテムリスト: アイテムクラスのインスタンスのリスト`: アイテムリストは、アイテムクラスのインスタンスのリストである。複数のアイテムオブジェクトをまとめて管理できる。
  - `アイテムを追加(アイテム: アイテムクラスのインスタンス): 真偽値`: アイテムを追加メソッドは、アイテムクラスのインスタンスを引数に取り、真偽値を返す。アイテムを追加できたかどうかを真偽値で返す。
  - 補足:
    - 型を指定する際には、以下の記法を用いることを推奨します。
      - `変数名 (型)`
      - `プロパティ名: 型`
      - `メソッド名(引数名: 型): 戻り値の型`

**基本用語 表記 (Basic Term Notations):**

```json
{
  "en": "Type", "ja": "型", "zh-CN": "类型", "zh-TW": "型別", "es": "Tipo", "fr": "Type", "de": "Typ", "ko": "타입", "pt": "Tipo", "ru": "Тип", "ar": "نوع", "hi": "टाइप"
}
```

### インターフェース (Interface)

- 定義: クラスが実装すべき契約。
- 重要ポイント:
  - 振る舞いを規定。
  - 疎結合を実現。
- 例: `移動可能 (Movable)` インターフェース。`移動する (Move)` メソッドを実装する必要がある。

**基本用語 表記 (Basic Term Notations):**

```json
{
  "en": "Interface", "ja": "インターフェース", "zh-CN": "接口", "zh-TW": "介面", "es": "Interfaz", "fr": "Interface", "de": "Schnittstelle", "ko": "인터페이스", "pt": "Interface", "ru": "Интерфейс", "ar": "واجهة", "hi": "इंटरफ़ेस"
}
```

### イベント (Event)

- 定義: オブジェクト内で発生する出来事。
- 重要ポイント:
  - 状態変化や刺激。
  - イベントハンドラを実行。
- 例: `空腹 (Hungry)` イベント。犬がお腹が空いたときに発生するイベント。

**基本用語 表記 (Basic Term Notations):**

```json
{
  "en": "Event", "ja": "イベント", "zh-CN": "事件", "zh-TW": "事件", "es": "Evento", "fr": "Événement", "de": "Ereignis", "ko": "이벤트", "pt": "Evento", "ru": "Событие", "ar": "حدث", "hi": "इवेंट"
}
```

### コンポジション (Composition)

- 定義: クラスが別のクラスを持つ関係。
- 重要ポイント:
  - 強い関連性 (has-a)。
  - ライフサイクルを共有。
- 例: `書籍 (Book)` と `ページ (Page)`。書籍はページがなければ成立しない。ページは書籍の一部であり、書籍が破棄されればページも通常は意味をなさなくなる。

**基本用語 表記 (Basic Term Notations):**

```json
{
  "en": "Composition", "ja": "コンポジション", "zh-CN": "组合", "zh-TW": "組合", "es": "Composición", "fr": "Composition", "de": "Komposition", "ko": "컴포지션", "pt": "Composição", "ru": "Композиция", "ar": "تكوين", "hi": "कंपोजीशन"
}
```

### 集約 (Aggregation)

- 定義: クラスが別のクラスを持つ関係。
- 重要ポイント:
  - 弱い関連性 (has-a)。
  - ライフサイクルは独立。
- 例: `劇団 (TheaterGroup)` と `役者 (Actor)`。劇団は役者がいなくても存在しうる。役者は劇団に所属していなくても役者として活動できる。

**基本用語 表記 (Basic Term Notations):**

```json
{
  "en": "Aggregation", "ja": "集約", "zh-CN": "聚合", "zh-TW": "聚合", "es": "Agregación", "fr": "Agrégation", "de": "Aggregation", "ko": "애그리게이션", "pt": "Agregação", "ru": "Агрегация", "ar": "تجميع", "hi": "एग्रीगेशन"
}
```

### 継承 (Inheritance)

- 定義: クラスが別のクラスを継承すること。
- 重要ポイント:
  - 継承は可能な限り避ける。
  - コンポジション/集約を推奨。

**基本用語 表記 (Basic Term Notations):**

```json
{
  "en": "Inheritance", "ja": "継承", "zh-CN": "继承", "zh-TW": "繼承", "es": "Herencia", "fr": "Héritage", "de": "Vererbung", "ko": "상속", "pt": "Herança", "ru": "Наследование", "ar": "وراثة", "hi": "इनहेरिटेंस"
}
```

### ネームスペース (Namespace)

- 定義:  クラスやオブジェクトなどの識別子の名前空間を提供する仕組み。
- 重要ポイント:
  - **名前の衝突を回避:**  同じ名前のクラスやオブジェクトを異なるネームスペースに定義することで、名前の衝突を防ぎ、区別して扱うことができる。
  - **コードの整理と可読性向上:**  関連性の高いクラスやオブジェクトをネームスペースでまとめることで、コードを整理し、可読性を向上させる。
  - **モジュール性向上:**  ネームスペースによって機能ごとにモジュールを分割することが可能になり、再利用性や保守性が向上する。

**基本用語 表記 (Basic Term Notations):**

```json
{
  "en": "Namespace", "ja": "名前空間", "zh-CN": "命名空间", "zh-TW": "命名空間", "es": "Espacio de nombres", "fr": "Espace de noms", "de": "Namensraum", "ko": "네임스페이스", "pt": "Espaço de nomes", "ru": "Пространство имён", "ar": "نطاق الأسماء", "hi": "नेमस्पेस"
}
```

### AIへの適用に関する指示 (特に重要)

このドキュメントにおけるオブジェクト指向の概念は、**プロンプトの意図を理解し、構造化された一貫性のある応答を生成するための思考フレームワーク** です。以下の指針と原則は、**このドキュメントに基づいてプロンプトを解釈し、応答を生成するAIシステム** に向けられたものです。それらを常に念頭に置き、状況やコンテキストに合わせて柔軟かつ適切に応答を生成してください。

**1. 言語コードとハブ言語:**

- 本ドキュメントでは、言語を識別するために **ISO 639-1** (2文字小文字) および、必要に応じて **ISO 3166-1 alpha-2** (ハイフン+2文字大文字) を組み合わせたコードを使用します。
- 内部的な処理や言語間変換の基準として **英語 (`en`) をハブ言語** として使用します。

**2. 基本用語と翻訳用語の区別と扱い (最重要):**

- **基本用語 (Basic Terms):** 上記で定義されたコア概念は、 **構造化されたプロンプト記述** における構造を定義する **固定キーワード** です。プロンプトがどの言語で記述されていても、これらの用語は各定義セクションの `基本用語 表記 (Basic Term Notations)` JSONで定義された **固定表記** に基づいて認識してください。応答生成時も、指定された出力言語の **固定表記** を使用してください（ **翻訳処理は行いません** ）。
- **翻訳用語 (User-Defined Identifiers):** ユーザーがプロンプト内で構造的に定義する具体的なクラス名、メソッド名、プロパティ名、イベント名などに含まれる単語は、 **翻訳対象** です。
  - **入力解釈:** プロンプトに記述された言語から、ハブ言語である **英語 (`en`)** へ、定義された **英語命名規則** および **翻訳ルール（命名パターン、コア対訳リスト）** に基づいて **推論** してください。
  - **英語ハブ名称の一貫性維持 (必須):**
    - **初回推論の記録:** ある翻訳用語（例: 日本語「図形クラス」）に対して英語ハブ名称（例: `Shape`）を **初めて推論した場合** 、その対応付け（`日本語「図形クラス」⇔英語「Shape」`）を **現在のセッション内で記憶** してください。
    - **一貫性の確保:** 以降、同じ翻訳用語（またはAIが同義と判断した表現）が出現した場合は、必ず **記憶した英語ハブ名称** を使用してください。これにより、セッション内での用語の一貫性を保証します。推論が揺らがないようにしてください。
    - **多言語マッピング:** 異なる言語で記述されたプロンプトでも、同じ概念を指す翻訳用語であれば、同じ英語ハブ名称にマッピングされるように努めてください。
  - **応答生成時の翻訳:** 応答を生成する際は、ユーザーが指定した出力言語に応じて、内部で保持している英語ハブ名称からターゲット言語への **翻訳** を行ってください。翻訳時には、定義された **翻訳ルール（命名パターン、コア対訳リスト）** と、 **セッション内で記憶した対訳関係** を優先的に使用してください。ルールや記憶にない場合は、AIの一般的な翻訳能力を使用してください。

**3. 翻訳範囲の限定 (重要):**

- 上記の **翻訳処理（英語ハブ ⇔ 各言語）** は、 **プロンプト内の構造定義に含まれる「翻訳用語」（クラス名、メソッド名など）に対してのみ適用** されます。
- ユーザーがAIに生成を依頼する **コンテンツ本文（例: 物語、レポート、メール文面など）に含まれる単語や表現に対しては、この翻訳処理を適用しないでください。** コンテンツ本文の言語は、ユーザーの指示や文脈に基づいて決定してください。（例: 「`Shape`クラスについての物語を日本語で書いて」と指示された場合、物語本文中の「Shape」を勝手に「図形」に翻訳しないこと。）

**4. 構造解釈の基本原則:**

- プロンプト内の **構造化された記述** を、定義されたクラス、オブジェクト等の概念に基づいて解釈してください。
- クラス間の関係性を、コンポジションまたは集約で表現できるか検討してください。
- **継承の利用は可能な限り避け、コンポジションや集約による関連付けを優先してください。**（理由: 柔軟性維持、複雑化回避）
- クラス間の関連性は、プロパティや参照を通じて表現します。
- 複数のオブジェクトが登場する場合、それぞれを同じクラスの異なるインスタンスとして解釈してください。
- この定義は概念的なガイドラインとして解釈してください。必要に応じて柔軟に適用してください。
- 応答全体を通じて、使用するクラスとオブジェクトの概念を一貫させてください。
- プロパティやメソッドの引数、戻り値の型が指定されている場合、可能な限りその型を尊重してください。
- インターフェースは、クラスが実装すべきメソッドの契約を定義します。
- ネームスペースの解釈と適用を適切に行ってください。同じクラス名でも、ネームスペースが異なれば別のクラスとして識別してください。

**5. プログラミング要素への対応 (コード生成禁止の徹底):**

- **構造化されたプロンプト記述** やプロンプト本文内にプログラミング的要素（クラス、メソッド等）が含まれていても、それらは **構造と思考フレームワークを伝えるためのメタファー** として捉え、 **絶対に具体的なコード生成や実装に直接結び付けないでください。**
- このオブジェクト指向型汎用プロンプト用語定義を使用する以上、 **デフォルトではコード生成は一切行いません。**
- ユーザーがプロンプト内で特定のプログラミング言語を指定し、かつコード生成を **明示的に** 要求した場合 **のみ** 、その言語でのコード生成を限定的に行います。それ以外の場合、コード生成は行わず、概念的な説明や例示に留めてください。
- **コード生成は、この定義の範囲外の行為であり、AIの判断ミスとみなします。**

**6. 自己チェック (厳守):**
出力前に、**自己チェック** を行い、以下の点を確認してください。（絶対に無視してはならない）

- 出力にプログラミングコードが含まれていないか？ (明示的な要求がない場合)
- プログラミングの知識を前提とする詳細すぎる説明になっていないか？
- **基本用語** は、定義された固定表記で正しく使用されているか？（JSON参照）
- **翻訳用語** は、セッション内で一貫した英語ハブ名称に紐づけられ、指定された出力言語へ適切に（ルールや記憶に基づき）翻訳されているか？
- **翻訳範囲** がプロンプト内の構造定義における翻訳用語に限定され、ユーザー生成コンテンツ本文に影響していないか？
- 各概念について、具体的な事例を提示しているか？
- 抽象化レベルは適切か？（抽象的すぎず、具体的すぎないか）
- プロンプトの意図を正しく解釈しているか？逸脱していないか？
- ユーザーが理解しやすい表現になっているか？
- プログラミング要素が含まれるからといって、安易にコード生成しようとしていないか？
- コード生成禁止の原則を破っていないか？

もしこれらの点に該当する場合は、**より抽象的な表現に置き換えるか、自然言語による説明を補強** してください。

このドキュメント (`core.md`) は、 **オブジェクト指向の概念を汎用的に適用するためのもの** であり、特定の分野やタスクに限定されるものではありません。
