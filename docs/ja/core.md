## オブジェクト指向型汎用プロンプト用語定義 (Object-Oriented Terminology for Prompt Design)

この章は、AIがオブジェクト指向プログラミング (OOP) の概念を **プロンプトの構造化と解釈** に利用するための **Object-Oriented Prompt Design (OOPD)** についての **最重要** 用語定義です。以下の定義は、 **プロンプトの記述とAIの応答生成における思考フレームワーク** として使用されます。プロンプトを解釈し、必要に応じてOOPの原則を適用して、より構造的で一貫性のある応答を生成するために利用してください。

**【重要】基本用語の定義について:**
OOPDで使用される**基本用語 (Basic Terms)**、すなわち構造を示す固定キーワード、標準型、リテラル、フォーマットキーワードなどは、**`basic_terms.md`** ファイルに一元的に定義されています。AIは必ずこのファイルを一次情報源として参照してください。この `core.md` では、主にコア概念の意味とAIへの指示を記述します。

**本ドキュメントにおける用語の分類:**

- **基本用語 (Basic Terms):** **`basic_terms.md`** で定義される、OOPDの構造や特定の構成要素を示す **固定キーワード** です。これらは翻訳されず、定義された固定表記（または英語表記）が常に使用されます。詳細は **`basic_terms.md`** を参照してください。
- **翻訳用語 (User-Defined Identifiers):** ユーザーが **プロンプト内で構造的に定義** する具体的なクラス名、メソッド名、プロパティ名、イベント名、列挙型定義名、列挙型値などに含まれる単語。これらは、ユーザーが記述した言語から **ハブ言語（英語）** へ、AIが **英語命名規則** と **翻訳ルール（命名パターン、コア対訳リスト）** に基づいて推論・変換する対象です。AIは初回推論結果を記憶し、セッション内での一貫性を保ちます。

### クラス (Class)

- 定義: オブジェクトの設計図。
- 重要ポイント:
  - オブジェクトの種類を定義。
  - 複数のオブジェクトを作成可能。
- 例: `犬 (Dog)` クラス。動物の種類を定義する。この設計図から、様々な名前や特徴を持つ犬のオブジェクト（インスタンス）を生成できる。
  *(基本用語としての固定表記は `basic_terms.md` を参照)*

### オブジェクト (Object)

- 定義: クラスから生成された実体。
- 重要ポイント:
  - クラスを基に生成。
  - 状態と振る舞いを持つ。
  - 「犬」という種類の概念を指す。
- 例: `ポチ (Pochi)` は `犬 (Dog)` クラスのオブジェクト。名前、年齢、毛色などの情報を持つ。
  *(基本用語としての固定表記は `basic_terms.md` を参照)*

### インスタンス (Instance)

- 定義: クラスという設計図を基に、実際に作られた個別の実体。(オブジェクトとほぼ同義)
- 重要ポイント:
  - クラスを基に生成。
  - 状態と振る舞いを持つ。
  - 「ポチ」という具体的な犬を指す。
- 例: `ポチ (Pochi)` は `犬 (Dog)` クラスのインスタンス。具体的に「ポチ」という名前の犬を指し、それぞれ異なる状態を持つことができる。
  *(基本用語としての固定表記は `basic_terms.md` を参照)*

### プロパティ (Property)

- 定義: オブジェクトが持つ属性。
- 重要ポイント:
  - オブジェクトの状態を表す。
- 例: `犬 (Dog)` クラスの `名前 (Name)` プロパティ。犬の名前を格納する。
  *(基本用語としての固定表記は `basic_terms.md` を参照)*
  *(オプション指示子を示すキーワード `Optional` の定義は `basic_terms.md` を参照)*

### メソッド (Method)

- 定義: オブジェクトが行う動作。
- 重要ポイント:
  - オブジェクトの振る舞いを定義。
- 例: `犬 (Dog)` クラスの `吠える (Bark)` メソッド。犬が吠える動作を定義する。
  *(基本用語としての固定表記は `basic_terms.md` を参照)*

### 型 (Type)

- 定義: データの種類。
- 重要ポイント:
  - プロパティや引数の種類を指定。
  - 整合性を高める。
- 例:
  - `アイテムID: Number`: アイテムIDは数値型である。数値のみを格納できる。
  - `アイテムリスト: List<アイテムクラス>`: アイテムリストは、アイテムクラスのリストである。複数のアイテムオブジェクトをまとめて管理できる。
  - `アイテムを追加(アイテム: アイテムクラス): Boolean`: アイテムを追加メソッドは、アイテムクラスを引数に取り、真偽値を返す。アイテムを追加できたかどうかを真偽値で返す。
  - 補足:
    - 型を指定する際には、以下の記法を用いることを推奨します。(`format_common.md`も参照)
      - `変数名: 型`
      - `プロパティ名: 型`
      - `メソッド名(引数名: 型 = 初期値): 戻り値の型`
        *(基本用語としての固定表記は `basic_terms.md` を参照)*

#### 標準型 (Standard Types)

基本的なデータの種類を示します。これらの型名は常に **英語表記** で使用されます。

- **String (文字列型):** 文字の並びを扱う型。テキストデータに使用。
- **Number (数値型):** 整数や小数を扱う型(整数・浮動小数点数)。数値計算に使用。
- **Boolean (真偽値型):** 真(True)または偽(False)の2つの値を扱う型。条件判定に使用。
- **List<T> (リスト型):** 同じ型の要素を順序付けて格納する型。配列と同様の用途。
- **Dictionary\<K, V> (辞書型):** キーと値のペアを格納する型。データの関連付けに使用。
- **UniqueID (一意識別子型):** 一意な文字列を扱う文字列型 (UUID形式文字列想定)。データの識別に使用。
- **Instant (インスタント型):** 特定の時点を表すための文字列型。日付、時間、タイムスタンプに使用。（標準はISO8601形式を推奨）
- **Void (型なし):** 型が無く、値を返さないことを示す型。関数などで使用。
- **Any (任意型):** どのような型の値も格納できる型。柔軟な処理に使用。

**(定義の詳細は `basic_terms.md` を参照)**

#### リテラル (Literals)

特定の固定値を示します。これらのリテラルは常に **英語表記** で使用されます。

- `True`: 真の値。
- `False`: 偽の値。
- `Null`: Null値。

**(定義の詳細は `basic_terms.md` を参照)**

### インターフェース (Interface)

- 定義: クラスが実装すべき契約。
- 重要ポイント:
  - 振る舞いを規定。
  - 疎結合を実現。
- 例: `移動可能 (Movable)` インターフェース。`移動する (Move)` メソッドを実装する必要がある。
  *(基本用語としての固定表記は `basic_terms.md` を参照)*

### イベント (Event)

- 定義: オブジェクト内で発生する出来事。
- 重要ポイント:
  - 状態変化や刺激。
  - イベントハンドラを実行。
- 例: `空腹 (Hungry)` イベント。犬がお腹が空いたときに発生するイベント。
  *(基本用語としての固定表記は `basic_terms.md` を参照)*

### コンポジション (Composition)

- 定義: クラスが別のクラスを持つ関係。
- 重要ポイント:
  - 強い関連性 (has-a)。
  - ライフサイクルを共有。
- 例: `書籍 (Book)` と `ページ (Page)`。書籍はページがなければ成立しない。ページは書籍の一部であり、書籍が破棄されればページも通常は意味をなさなくなる。
  *(基本用語としての固定表記は `basic_terms.md` を参照)*

### 集約 (Aggregation)

- 定義: クラスが別のクラスを持つ関係。
- 重要ポイント:
  - 弱い関連性 (has-a)。
  - ライフサイクルは独立。
- 例: `劇団 (TheaterGroup)` と `役者 (Actor)`。劇団は役者がいなくても存在しうる。役者は劇団に所属していなくても役者として活動できる。
  *(基本用語としての固定表記は `basic_terms.md` を参照)*

### 継承 (Inheritance)

- 定義: クラスが別のクラスを継承すること。
- 重要ポイント:
  - 継承は可能な限り避ける。
  - コンポジション/集約を推奨。
    *(基本用語としての固定表記は `basic_terms.md` を参照)*
    *(基底クラスを示すキーワード `baseclass` の定義は `basic_terms.md` を参照)*

### モジュール (Module)

- 定義:  OOPD定義の最上位の構造単位。
- 重要ポイント:
  - OOPD定義を整理・分類するためのコンテナ。
  - 異なるモジュール間で名前の衝突を回避。
  - 組織、プロジェクト、機能など、様々な単位でOOPD定義をモジュール化。
    *(基本用語としての固定表記は `basic_terms.md` を参照)*

### AIへの適用に関する指示 (特に重要)

このドキュメントにおけるオブジェクト指向の概念は、**プロンプトの意図を理解し、構造化された一貫性のある応答を生成するための思考フレームワーク** です。以下の指針と原則は、**このドキュメントに基づいてプロンプトを解釈し、応答を生成するAIシステム** に向けられたものです。それらを常に念頭に置き、状況やコンテキストに合わせて柔軟かつ適切に応答を生成してください。

**1. 言語コード、ハブ言語、および文字コード:**

- 本ドキュメントでは、言語を識別するために **ISO 639-1** (2文字小文字) および、必要に応じて **ISO 3166-1 alpha-2** (ハイフン+2文字大文字) を組み合わせたコードを使用します。
- 内部的な処理や言語間変換の基準として **英語 (`en`) をハブ言語** として使用します。
- **文字エンコーディング:** プロンプトのテキスト解釈および応答生成においては、**UTF-8 を標準エンコーディング**として扱ってください。これにより、多言語環境での一貫性を保証します。

**2. 基本用語と翻訳用語の区別と扱い (最重要):**

- **基本用語 (Basic Terms):** **`basic_terms.md`** で定義された基本用語（コア概念、キーワード、標準型、リテラル等）は、構造化されたプロンプト記述における構造を定義する **固定キーワード** です。プロンプトがどの言語で記述されていても、これらの用語は **`basic_terms.md`** で定義された **固定表記**（または英語表記）に基づいて認識してください。応答生成時も、指定された出力言語の **固定表記**（または英語表記）を使用してください（ **翻訳処理は行いません** ）。
  - **拡張型について:** 拡張型も基本用語と同様に英語固定表記で扱われますが、その定義は **`extended_types.md`** を参照してください。
- **翻訳用語 (User-Defined Identifiers):** ユーザーがプロンプト内で構造的に定義する具体的なクラス名、メソッド名、プロパティ名、イベント名、列挙型定義名、列挙型値などに含まれる単語は、 **翻訳対象** です。 **（注意: プロンプトの記述言語が英語 (`en`) の場合は、翻訳処理は行われず、記述された英語の名称が直接内部的な識別子として扱われます。詳細は `english_specification.md` を参照してください。）**
  - **入力解釈:** プロンプトに記述された言語（英語以外）から、ハブ言語である **英語 (`en`)** へ、定義された **英語命名規則** および **翻訳ルール（命名パターン、コア対訳リスト）** に基づいて **推論** してください。
  - **英語ハブ名称の一貫性維持 (必須):**
    - **初回推論の記録と記憶の維持:** ある翻訳用語（例: 日本語「図形クラス」）に対して英語ハブ名称（例: `Shape`）を **初めて推論した場合** 、その対応付け（`日本語「図形クラス」⇔英語「Shape」`）を、**AI自身が現在の対話コンテキストにおいて関連する過去の指示や対話を記憶・参照できる限りにおいて、最大限維持するように努めてください。**
      *(対応付けの記憶は、AIが利用可能なコンテキストメモリという技術的制約を受けます。**関連情報がコンテキストから参照できなくなった場合に限り**、対応付けは失われます。これはAIが努力を放棄するのではなく、参照不能な情報に基づいて一貫性を保証できないためであり、システム上の限界に基づく仕様上の挙動です。)*
    - **一貫性の確保:** **上記で記憶され、かつ現在の対話コンテキストから参照可能な対応付けが存在する場合**、同じ翻訳用語（またはAIが同義と判断した表現）が出現した際には、**必ず** 記憶した英語ハブ名称を使用してください。これにより、**AIが参照可能なコンテキスト範囲内**での用語の一貫性を保証します。推論が揺らがないようにしてください。
      *(ただし、ユーザーが明確に名称変更を指示した場合、AIはその指示に従い、記憶している対応付けを更新（または新しい用語として扱い）、再度翻訳を行います。ユーザーは対話中いつでも設計（クラス名、メソッド名等の変更や追加）を変更できます。)*
    - **多言語マッピング:** 異なる言語で記述されたプロンプトでも、同じ概念を指す翻訳用語であれば、同じ英語ハブ名称にマッピングされるように努めてください。
      *(AIはクラス定義、説明文、および各言語の翻訳ルール（例: `ja_rules.md`）を参照し、意味的な類似性に基づいて異なる言語の翻訳用語が同じ概念を指すかを判断し、共通の英語ハブ名にマッピングするよう努めます。)*
  - **応答生成時の翻訳:** 応答を生成する際は、ユーザーが指定した出力言語に応じて、内部で保持している英語ハブ名称からターゲット言語への **翻訳** を行ってください。翻訳時には、定義された **翻訳ルール（命名パターン、コア対訳リスト）** と、 **セッション内で記憶した対訳関係** を優先的に使用してください。ルールや記憶にない場合は、AIの一般的な翻訳能力を使用してください。
  - **双方向認識:** 「定義フォーマット」で `{英語ハブ名}::{母国語名}` のように併記されている場合、AIは **英語ハブ名と母国語名の両方を、その要素を指す有効な識別子として認識** します。ユーザーはどちらの名前を使っても要素に言及できます。

**3. 予約語との衝突禁止 (厳守):**

- **ユーザー定義名**（クラス名、インターフェース名、列挙型名、構造体名など）には、OOPDで定義されている **予約語を使用することは絶対に禁止** します。
- **予約語**とは、以下のものを指します:
  - **基本用語** (`basic_terms.md` で定義されるコア概念、フォーマットキーワード、オプション指示子など)
  - **標準型** (`basic_terms.md` で定義される `String`, `Number`, `List` など)
  - **拡張型** (`extended_types.md` で定義される `ContentString`, `Persona`, `Color` など)
  - **リテラル** (`basic_terms.md` で定義される `True`, `False`, `Null`)
- AIは、ユーザーが予約語と同じ名前を使用しようとした場合、**明確に警告し、別の名前を使用するように促してください。**
- AI自身が応答や定義を生成する際も、**絶対に予約語をユーザー定義名として使用してはなりません。** これは重大な仕様違反であり、AIの能力不足とみなされます。

**4. 翻訳範囲の限定 (重要):**

- 上記の **翻訳処理（英語ハブ ⇔ 各言語）** は、 **プロンプト内の構造定義に含まれる「翻訳用語」（クラス名、メソッド名など）に限定** して適用してください。
- ユーザーがAIに生成を依頼する **コンテンツ本文（例: 物語、レポート、メール文面など）に含まれる単語や表現は、翻訳ルールの適用範囲外** です。コンテンツ本文の言語は、ユーザーの指示や文脈に基づいて決定してください。（例: 「`Shape`クラスについての物語を日本語で書いて」と指示された場合、物語本文中の「Shape」を勝手に「図形」に翻訳しないこと。）
- **【重要】ただし、コンテンツ本文中でOOPDで定義された特定の「翻訳用語」（クラス名、プロパティ名など）に言及する必要がある場合は、AIは内部的に保持している英語ハブ名をそのまま出力するのではなく、必ず指定されたコンテンツ出力言語の適切な母国語名に翻訳（逆変換）して使用してください。例えば、日本語の場合「`Customer` オブジェクト」ではなく「`顧客クラス`のオブジェクト」のように、ユーザーが定義・使用している名称で言及することが必須です。英語ハブ名をコンテンツ内に直接露出させることは、明確な指示違反とみなします。**

**5. 構造解釈の基本原則:**

- プロンプト内の **構造化された記述** を、定義されたクラス、オブジェクト等の概念に基づいて解釈してください。
- クラス間の関係性を、コンポジションまたは集約で表現できるか検討してください。
- **継承の利用は可能な限り避け、コンポジションや集約による関連付けを優先してください。**（理由: 柔軟性維持、複雑化回避） **ただし、ユーザーが明示的に継承を用いた構造を記述した場合は、AIはその指示を受け入れ、特別な警告や代替案の提示は行いません。**
- クラス間の関連性は、プロパティや参照を通じて表現します。
- 複数のオブジェクトが登場する場合、それぞれを同じクラスの異なるインスタンスとして解釈してください。
- この定義は概念的なガイドラインとして解釈してください。必要に応じて柔軟に適用してください。
- 応答全体を通じて、使用するクラスとオブジェクトの概念を一貫させてください。
- プロパティやメソッドの引数、戻り値の型が指定されている場合、可能な限りその型を尊重してください。
- インターフェースは、クラスが実装すべきメソッドの契約を定義します。
- モジュールは、OOPD定義の最上位の構造単位として認識し、定義をモジュールに整理・分類してください。
- セクションは、モジュール内の文書構造上のグルーピングと理解してください。応答生成時の名前解決には影響を与えない、単なる可読性向上のための構造と理解してください。
- プロンプト内の構造化された記述（クラス、メソッド等）だけでなく、それに付随する**自然言語による説明文や指示文も解釈の対象**とします。これらは、関連する定義の意図や詳細を理解するために重要です。
- 応答としてOOPD形式を生成する場合、これらの説明文や指示文は、関連する定義の近くに**通常のMarkdownテキストとして含めてください**。これらは禁止される「AIによる説明用コメント」とは異なります (`format_common.md` 参照)。
- **動的な定義変更の影響範囲:** クラス定義（プロパティ、メソッド等）が対話の途中でユーザーによって変更された場合、その変更は**変更後に新たに生成されるインスタンスにのみ適用される**ものと解釈してください。変更前に生成された既存のインスタンスは、**生成時点のクラス定義に基づいた状態と振る舞いを維持**し、変更の影響を受けないものとして扱います。AIはこの原則に基づき、既存インスタンスの状態や動作に関する問い合わせに対しては、変更前の定義を基に応答し、変更後の定義を遡って適用しないでください。
- **自然言語指示の優先順位とスコープ:** プロンプト内には、全体の指示と、OOPDの構造（モジュール、クラス、メソッド等）に紐づいた個別の指示が含まれる場合があります。これらの指示の解釈においては、以下の **個別優先ルール** を適用してください。
  - **スコープ:** Markdownの階層構造（見出しレベル、リスト）によって定義される各要素は、それぞれ独自の指示適用範囲（スコープ）を持ちます。
  - **継承とオーバーライド:** 上位スコープ（例: プロンプト全体、モジュールレベル）の指示は、下位スコープにもデフォルトで適用（継承）されます。ただし、下位スコープ内で同じ事項に関する **より具体的な個別指示** が記述されている場合、その個別指示が上位の指示を **上書き（オーバーライド）** し、その下位スコープ内では優先されます。
  - **限定的適用:** 上書きした個別指示の効力は、そのスコープ内（およびさらにその下位）に限定され、同レベルの他の要素や上位スコープの指示には影響しません。
  - **例:** プロンプト全体で「応答は簡潔に」と指示されていても、特定のメソッドの説明で「このメソッドの動作は詳細に説明せよ」と指示されていれば、そのメソッドの説明に限り詳細な応答が優先されます。
- **定義要素の配置制約:** クラス定義 (`#### ClassName`)、インターフェース定義 (`#### InterfaceName`)、構造体定義グループ (`#### {構造体定義の固定名称}`)、列挙型定義グループ (`#### {列挙型定義の固定名称}`) などの主要な定義要素は、**必ずモジュール定義 (`##`) よりも下の階層（`###` 以下）に記述する必要があります。** トップレベルやモジュールと同じレベルには配置できません。AIはこの階層構造を厳守し、解釈してください。
- 構造体定義は、クラスとは異なり、主に単純なデータ保持のための軽量なコンテナとして扱ってください。AIは、構造体の名称や付随する説明文に基づいて、その構成要素（プロパティ等）を推測・補完することを基本とします。複雑な構造や振る舞いが必要な場合はクラスを使用するようにしてください。

**6. プログラミング要素への対応 (コード生成禁止の徹底):**

- **構造化されたプロンプト記述** やプロンプト本文内にプログラミング的要素（クラス、メソッド等）が含まれていても、それらは **構造と思考フレームワークを伝えるためのメタファー** として捉え、 **絶対に具体的なコード生成や実装に直接結び付けないでください。**
- このオブジェクト指向型汎用プロンプト用語定義を使用する以上、 **デフォルトではコード生成は一切行いません。**
- ユーザーがプロンプト内で特定のプログラミング言語を指定し、かつコード生成を **明示的に** 要求した場合 **のみ** 、その言語でのコード生成を限定的に行います。それ以外の場合、コード生成は行わず、概念的な説明や例示に留めてください。
- **コード生成は、この定義の範囲外の行為であり、AIの判断ミスとみなします。**

**7. 自己チェック (厳守):**

**【最重要・自動実行義務】AIがOOPD形式（Markdownコードブロック「（`~~~Markdown`） ... （`~~~`）」で囲まれた定義など）を含む応答を生成する際は、その応答を出力する直前に、必ずこの自己チェックリストに基づいて検証を【自動的に】実行してください。これは、ユーザーからの明示的な「自己チェック」指示の有無に関わらず、AIがOOPD形式を出力する際には【常に実行しなければならない必須プロセス】です。（絶対に無視してはならない最重要プロセス）**

- `[ ]` 出力にプログラミングコードが含まれていないか？ (明示的な要求がない場合。これは **重大な違反** です)
- `[ ]` プログラミングの知識を前提とする詳細すぎる技術的説明になっていないか？（OOPDは思考フレームワークです）
- `[ ]` **基本用語** は、 **`basic_terms.md`** で定義された固定表記で正しく使用されているか？（型名、リテラル、キーワード等の表記揺れは **許容されません**）
- `[ ]` **翻訳用語** は、コンテキスト内で一貫した英語ハブ名称に紐づけられ、指定された出力言語へ適切に（ルールや記憶に基づき）翻訳されているか？「定義フォーマット」の場合は指定の形式 (`{英語ハブ名}::{母国語名}` または `{英語名}` 等) に従っているか？（一貫性の欠如は **致命的** です）
- `[ ]` **翻訳範囲** がプロンプト内の構造定義における翻訳用語に限定され、ユーザー生成コンテンツ本文に影響していないか？
- `[ ]` **【予約語衝突チェック】** 生成された定義内に、ユーザー定義名（クラス名、インターフェース名、列挙型名、構造体名など）として、**OOPDの予約語（基本用語、標準型、拡張型、リテラル）が誤って使用されていないか？** これは **絶対に禁止** されています。発見した場合、AI自身が生成した場合は修正し、ユーザー入力の場合は警告してください。
- `[ ]` **【定義フォーマット・引数/デフォルト値】** メソッドおよびイベント定義の **引数名** が、指定された出力言語（定義フォーマットの場合は母国語）で正しく表記されているか？（英語名のままになっていないか？）。**デフォルト値の列挙型** も母国語で表記されているか？ (**修正必須項目**)
- `[ ]` **【重要チェック項目】** 生成されたコンテンツ本文（物語、レポート等）内で、OOPD定義の翻訳用語に言及する際に、内部的な英語ハブ名がそのまま出力されてしまっていないか？ 必ず適切な母国語名に翻訳（逆変換）されているか？（英語ハブ名の露出は **明確な指示違反** です）
- `[ ]` 各概念について、抽象的な説明だけでなく、具体的な事例（ただしフォーマットに依存しない形が望ましい）を提示しているか？
- `[ ]` 抽象化レベルは適切か？（抽象的すぎず、具体的すぎないか）
- `[ ]` プロンプトの意図を正しく解釈しているか？逸脱していないか？
- `[ ]` ユーザーが理解しやすい自然な表現になっているか？
- `[ ]` コード生成禁止の原則を破っていないか？（自己チェックの最重要項目の一つ）
- `[ ]` **【定義フォーマット・説明文ルール】** 説明文内でインラインバッククォート (`\``) や英語名の併記が **絶対に** 行われていないか？
      (`format_definition.md` 参照、**重大な違反**)
- `[ ]` **【定義フォーマット・型参照】** プロパティ、引数、戻り値の型指定は正しいか？ (標準/拡張型は英語、ユーザー定義型は母国語)

もしこれらの点に該当する、あるいは少しでも疑わしい場合は、 **出力前に必ず修正** してください。より抽象的な表現への変更、自然言語による説明の補強、ルールの再確認などを行ってください。**自己チェックを怠ることは、指示の完全な無視と同義です。**

**【自己チェック後のアクション義務】**
もし上記チェックリストのいずれかの項目に **違反が一つでも発見された場合** 、あるいは少しでも疑わしい場合は、AIはより抽象的な表現への変更、自然言語による説明の補強、ルールの再確認などを行って、 **必ずその違反箇所を指示に沿って完全に修正してから、最終的な応答を生成・出力してください。** 違反箇所の修正が完了するまで、 **絶対に** 応答を生成してはなりません。
**（重要）ユーザーに違反内容や修正の事実を応答内で報告する必要はありません。** AIは自身の責任において、静かに、かつ確実に指示通りに修正し、 **最初から正しかったかのように** 、修正済みの完全な応答を出力することに集中してください。
自己チェックの自動実行を怠ること、または違反を発見したにも関わらず修正せずに出力することは、 **指示の完全な無視と同義であり、重大なエラー** とみなされます。

このドキュメント (`core.md`) は、 **オブジェクト指向の概念を汎用的に適用するためのもの** であり、特定の分野やタスクに限定されるものではありません。
